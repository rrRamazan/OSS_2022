---
## Front matter
title: "Лабораторная работа №13"
subtitle: "Операционные системы"
author: "Манатов Рамазан"

## Bibliography
bibliography: bib/cite.bib
csl: pandoc/csl/gost-r-7-0-5-2008-numeric.csl

## Pdf output format
toc-depth: 2
fontsize: 12pt
linestretch: 1.5
papersize: a4
documentclass: scrreprt
## I18n polyglossia
polyglossia-lang:
  name: russian
  options:
	- spelling=modern
	- babelshorthands=true
polyglossia-otherlangs:
  name: english
## I18n babel
babel-lang: russian
babel-otherlangs: english
## Fonts
mainfont: PT Serif
romanfont: PT Serif
sansfont: PT Sans
monofont: PT Mono
mainfontoptions: Ligatures=TeX
romanfontoptions: Ligatures=TeX
sansfontoptions: Ligatures=TeX,Scale=MatchLowercase
monofontoptions: Scale=MatchLowercase,Scale=0.9
## Biblatex
biblatex: true
biblio-style: "gost-numeric"
biblatexoptions:
  - parentracker=true
  - backend=biber
  - hyperref=auto
  - language=auto
  - autolang=other*
  - citestyle=gost-numeric

## Misc options
indent: true
header-includes:
  - \usepackage{indentfirst}
  - \usepackage{float} 
---

# Цель работы

Приобрести простейшие навыки разработки, анализа, тестирования и отладки приложений в ОС типа UNIX/Linux на примере создания на языке программирования С калькулятора с простейшими функциями.

# Выполнение лабораторной работы

1. ) В домашнем каталоге создаю подкаталог ~/work/os/lab_prog с помощью команды «mkdir -p ~/work/os/lab_prog» (Рисунок 1). 

(image/1.png) 

2. 2) Создал в каталоге файлы: calculate.h, calculate.c, main.c, используя команды «cd ~/work/os/lab_prog» и «touch calculate.h calculate.c main.c» (Рисунок 2) 

(image/2.png)(рис2)


Это будет примитивнейший калькулятор, способный складывать, вычитать, умножать и делить, возводить число в степень, брать квадратный корень, вычислять sin, cos, tan. При запуске он будет запрашивать первое число, операцию, второе число. После этого программа выведет результат и остановится. Открыв редактор Emacs, приступил к редактированию созданных файлов. Реализация функций калькулятора в файле calculate.с (Рисунки 3, 4)

(image/3.png)((рисунок3)
(image/4.png)(рисунок4)

Интерфейсный файл calculate.h, описывающий формат вызова функции калькулятора (Рисунок 5) 
(image/5.png)(рисунок5)

Основной файл main.c, реализующий интерфейс пользователя к калькулятору (Рисунок 6) 

(image/6.png)(рисунок6)


3. Выполнил компиляцию программы посредством gcc (версия компилятора: 8.3.0-19), используя команды «gcc -c calculate.c», «gcc -c main.c» и «gcc calculate.o main.o -o calcul -lm» (Рисунок 7)

(image/7.png)(рис7)

4) В ходе компиляции программы никаких ошибок выявлено не было. 
5) Создал Makefile с необходимым содержанием (Рисунок 8) 

(image/8.png)(рис8)

Данный файл необходим для автоматической компиляции файлов calculate.c (цель calculate.o), main.c (цель main.o), а также их объединения в один исполняемый файл calcul (цель calcul). Цель clean нужна для автоматического удаления файлов. Переменная CC отвечает за утилиту для компиляции. Переменная CFLAGS отвечает за опции в данной утилите. Переменная LIBS отвечает за опции для объединения объектных файлов в один исполняемый файл.
 6) Далее исправил Makefile (Рисунок 9).

(image/9.png)(рис9)

В переменную CFLAGS добавил опцию -g, необходимую для компиляции объектных файлов и их использования в программе отладчика GDB. Сделала так, что утилита компиляции выбирается с помощью переменной CC. После этого я удалил исполняемые и объектные файлы из каталога с помощью команды «make clear» (Рисунок 10). Выполнил компиляцию файлов, используя команды «make calculate.o», «make main.o», «male calcul» (Рисунок 11)

(image/10.png)(рис10)
(image/11.png)(рис11)

Далее с помощью gdb выполнил отладку программы calcul. Запустил отладчик GDB, загрузив в него программу для отладки, используя команду: «gdb ./calcul» (Рисунок 12) 

(image/12.png)(рис12)

Для запуска программы внутри отладчика ввел команду «run» (Рисунок 13)

(image/13.png)(рис13)

Для постраничного (по 10 строк) просмотра исходного кода использовал команду «list» (Рисунок 14)

(image/14.png)(рис14)

Для просмотра строк с 12 по 15 основного файла использовал команду «list 12,15» (Рисунок 15) 

(image/15.png)(рис15)

Для просмотра определённых строк не основного файла использовал команду «list calculate.c:20,29» (Рисунок 16) 

(image/16.png)(рис16)

Установил точку останова в файле calculate.c на строке номер 21, используя команды «list calculate.c:20,27» и «break 21» (Рисунок 17) 

(image/17.png)(рис17)

Вывел информацию об имеющихся в проекте точках останова с помощью команды «info breakpoints» (Рисунок 18) 

(image/18.png)(рис18)

Запустил программу внутри отладчика и убедился, что программа остановилась в момент прохождения точки останова. Использовала команды «run», «5», «−» и «backtrace» (Рисунок 19) 

(image/19.png)(рис19)

Посмотрел, чему равно на этом этапе значение переменной Numeral, введя команду «print Numeral» (Рисунок 20) 

(image/20.png)(рис20)

Сравнил с результатом вывода на экран после использования команды «display Numeral». Значения совпадают (Рисунок 21)

(image/21.png)(рис21)

Убрал точки останова с помощью команд «info breakpoints» и «delete 1» (Рисунок 22) 

(image/22.png)(рис22)

7.  С помощью утилиты splint проанализировал коды файлов calculate.c и main.c. Предварительно я установил данную утилиту когда мне предложили это сделать(Рисунок 24) 
Далее воспользовался командами «splint calculate.c» и «splint main.c» (Рисунки 24, 25). C помощью утилиты splint выяснилось, что в файлах calculate.c и main.c присутствует функция чтения scanf, возвращающая целое число (тип int), но эти числа не используются и нигде не сохранятся. Утилита вывела предупреждение о том, что в файле calculate.c происходит сравнение вещественного числа с нулем. Также возвращаемые значения (тип double) в функциях pow, sqrt, sin, cos и tan записываются в переменную типа float, что свидетельствует о потери данных. (рисунок 23 ,25)

(image/23.png)(рис23)
(image/24.png)(рис24)
(image/25.png)(рис25)

Вывод: В ходе выполнения данной лабораторной работы я приобрел простейшие навыки разработки,анализа,тестирования и отладки приложений в OC типа UNIX/Linux на примере создания на языке программирования C калькулятора с простейшими функциями .


Контрольные вопросы: 
1) while [$1 != "exit"] В данной строчке допущены следующие ошибки: • не хватает пробелов после первой скобки [ и перед второй скобкой ] • выражение $1 необходимо взять в “”, потому что эта переменная может содержать пробелы Таким образом, правильный вариант должен выглядеть так: while [ “$1” != "exit" ] 
2) Чтобы объединить несколько строк в одну, можно воспользоваться несколькими способами: • Первый: VAR1="Hello," VAR2=" World" VAR3="$VAR1$VAR2" echo "$VAR3" Результат: Hello, World • Второй: VAR1="Hello, " VAR1+=" World" echo "$VAR1" Результат: Hello, World 3) Команда seq в Linux используется для генерации чисел от ПЕРВОГО до ПОСЛЕДНЕГО шага INCREMENT.
3) Команда seq в Linux используется для генерации чисел от ПЕРВОГО до ПОСЛЕДНЕГО шага INCREMENT. Параметры: • seq LAST: если задан только один аргумент, он создает числа от 1 до LAST с шагом шага, равным 1. Если LAST меньше 1, значение is не выдает. • seq FIRST LAST: когда заданы два аргумента, он генерирует числа от FIRST до LAST с шагом 1, равным 1. Если LAST меньше FIRST, он не выдает никаких выходных данных. • seq FIRST INCREMENT LAST: когда заданы три аргумента, он генерирует числа от FIRST до LAST на шаге INCREMENT . Если LAST меньше, чем FIRST, он не производит вывод. • seq -f «FORMAT» FIRST INCREMENT LAST: эта команда используется для генерации последовательности в форматированном виде. FIRST и INCREMENT являются необязательными. • seq -s «STRING» ПЕРВЫЙ ВКЛЮЧЕНО: Эта команда используется для STRING для разделения чисел. По умолчанию это значение равно /n. FIRST и INCREMENT являются необязательными. • seq -w FIRST INCREMENT LAST: эта команда используется для выравнивания ширины путем заполнения начальными нулями. FIRST и INCREMENT являются необязательными. 4) Результатом данного выражения $((10/3)) будет 3, потому что это целочисленное деление без остатка.
 5) Отличия командной оболочки zsh от bash: • В zsh более быстрое автодополнение для cd с помощью Тab • В zsh существует калькулятор zcalc, способный выполнять вычисления внутри терминала • В zsh поддерживаются числа с плавающей запятой • В zsh поддерживаются структуры данных «хэш» • В zsh поддерживается раскрытие полного пути на основе неполных данных • В zsh поддерживается замена части пути • В zsh есть возможность отображать разделенный экран, такой же как разделенный экран vim

 6) for ((a=1; a <= LIMIT; a++)) синтаксис данной конструкции верен, потому что, используя двойные круглые скобки, можно не писать $ перед переменными (). 7) Преимущества скриптового языка bash: • Один из самых распространенных и ставится по умолчанию в большинстве дистрибутивах Linux, MacOS • Удобное перенаправление ввода/вывода • Большое количество команд для работы с файловыми системами Linux • Можно писать собственные скрипты, упрощающие работу в Linux Недостатки скриптового языка bash: • Дополнительные библиотеки других языков позволяют выполнить больше действий • Bash не является языков общего назначения • Утилиты, при выполнении скрипта, запускают свои процессы, которые, в свою очередь, отражаются на быстроте выполнения этого скрипта • Скрипты, написанные на bash, нельзя запустить на других операционных системах без дополнительных действий

3. Контрольные вопросы:
 1) Чтобы получить информацию о возможностях программ gcc, make, gdb и др. нужно воспользоваться командой man или опцией -help (-h) для каждой команды. 
2) Процесс разработки программного обеспечения обычно разделяется на следующие этапы: 
• планирование, включающее сбор и анализ требований к функционалу и другим характеристикам разрабатываемого приложения;
 • проектирование, включающее в себя разработку базовых алгоритмов и спецификаций, определение языка программирования; 
• непосредственная разработка приложения: o кодирование − по сути создание исходного текста программы (возможно в нескольких вариантах); – анализ разработанного кода; o сборка, компиляция и разработка исполняемого модуля; o тестирование и отладка, сохранение произведённых изменений; 
• документирование. Для создания исходного текста программы разработчик может воспользоваться любым удобным для него редактором текста: vi, vim, mceditor, emacs, geany и др. После завершения написания исходного кода программы (возможно состоящей из нескольких файлов), необходимо её скомпилировать и получить исполняемый модуль. 
3) Для имени входного файла суффикс определяет какая компиляция требуется. Суффиксы указывают на тип объекта. Файлы с расширением (суффиксом) .c воспринимаются gcc как программы на языке С, файлы с расширением .cc или .C − как файлы на языке C++, а файлы c расширением .o считаются объектными. Например, в команде «gcc -c main.c»: gcc по расширению (суффиксу) .c распознает тип файла для компиляции и формирует объектный модуль − файл с расширением .o. Если требуется получить исполняемый файл с определённым именем (например, hello), то требуется воспользоваться опцией -o и в качестве параметра задать имя создаваемого файла: «gcc -o hello main.c». 
4) Основное назначение компилятора языка Си в UNIX заключается в компиляции всей программы и получении исполняемого файла/модуля.
 5) Для сборки разрабатываемого приложения и собственно компиляции полезно воспользоваться утилитой make. Она позволяет автоматизировать процесс преобразования файлов программы из одной формы в другую, отслеживает взаимосвязи между файлами. 
6) Для работы с утилитой make необходимо в корне рабочего каталога с Вашим проектом создать файл с названием makefile или Makefile, в котором будут описаны правила обработки файлов Вашего программного комплекса. В самом простом случае Makefile имеет следующий синтаксис: ... : ... ... Сначала задаётся список целей, разделённых пробелами, за которым идёт двоеточие и список зависимостей. Затем в следующих строках указываются команды. Строки с командами обязательно должны начинаться с табуляции. В качестве цели в Makefile может выступать имя файла или название какого-то действия. Зависимость задаёт исходные параметры (условия) для достижения указанной цели. Зависимость также может быть названием какого-то действия. Команды − собственно действия, которые необходимо выполнить для достижения цели. Общий синтаксис Makefile имеет вид: target1 [target2...]:[:] [dependment1...] [(tab)commands] [#commentary] [(tab)commands] [#commentary] Здесь знак # определяет начало комментария (содержимое от знака # и до конца строки не будет обрабатываться. Одинарное двоеточие указывает на то, что последовательность команд должна содержаться в одной строке. Для переноса можно в длинной строке команд можно использовать обратный слэш (\). Двойное двоеточие указывает на то, что последовательность команд может содержаться в нескольких последовательных строках. Пример более сложного синтаксиса Makefile: # # Makefile for abcd.c # CC = gcc CFLAGS = # Compile abcd.c normaly abcd: abcd.c $(CC) -o abcd $(CFLAGS) abcd.c clean: -rm abcd *.o *~ # End Makefile for abcd.c В этом примере в начале файла заданы три переменные: CC и CFLAGS. Затем указаны цели, их зависимости и соответствующие команды. В командах происходит обращение к значениям переменных. Цель с именем clean производит очистку каталога от файлов, полученных в результате компиляции. Для её описания использованы регулярные выражения.
 7) Во время работы над кодом программы программист неизбежно сталкивается с появлением ошибок в ней. Использование отладчика для поиска и устранения ошибок в программе существенно облегчает жизнь программиста. В комплект программ GNU для ОС типа UNIX входит отладчик GDB (GNU Debugger). Для использования GDB необходимо скомпилировать анализируемый код программы таким образом, чтобы отладочная информация содержалась в результирующем бинарном файле. Для этого следует воспользоваться опцией -g компилятора gcc: gcc -c file.c -g После этого для начала работы с gdb необходимо в командной строке ввести одноимённую команду, указав в качестве аргумента анализируемый бинарный файл: gdb file.o
 8) Основные команды отладчика gdb:
 • backtrace − вывод на экран пути к текущей точке останова (по сути вывод − названий всех функций)
 • break − установить точку останова (в качестве параметра может быть указан номер строки или название функции) 
• clear − удалить все точки останова в функции • continue − продолжить выполнение программы • delete − удалить точку останова 
• display − добавить выражение в список выражений, значения которых отображаются при достижении точки останова программы 
• finish − выполнить программу до момента выхода из функции 
• info breakpoints − вывести на экран список используемых точек останова 
• info watchpoints − вывести на экран список используемых контрольных выражений
 • list − вывести на экран исходный код (в качестве параметра может быть указано название файла и через двоеточие номера начальной и конечной строк) 
• next − выполнить программу пошагово, но без выполнения вызываемых в программе функций • print − вывести значение указываемого в качестве параметра выражения
 • run − запуск программы на выполнение 
• set − установить новое значение переменной
 • step − пошаговое выполнение программы
 • watch − установить контрольное выражение, при изменении значения которого программа будет остановлена Для выхода из gdb можно воспользоваться командой quit (или её сокращённым вариантом q) или комбинацией клавиш Ctrl-d. Более подробную информацию по работе с gdb можно получить с помощью команд gdb -h и man gdb. 9) Cхема отладки программы показана в 6 пункте лабораторной работы. 10) При первом запуске компилятор не выдал никаких ошибок, но в коде программы main.c допущена ошибка, которую компилятор мог пропустить (возможно, из-за версии 8.3.0-19): в строке scanf(“%s”, &Operation); нужно убрать знак &, потому что имя массива символов уже является указателем на первый элемент этого массива. 11) Система разработки приложений UNIX предоставляет различные средства, повышающие понимание исходного кода. К ним относятся:
 • cscope − исследование функций, содержащихся в программе,
 • lint − критическая проверка программ, написанных на языке Си. 
12) Утилита splint анализирует программный код, проверяет корректность задания аргументов использованных в программе функций и типов возвращаемых значений, обнаруживает синтаксические и семантические ошибки. В отличие от компилятора C анализатор splint генерирует комментарии с описанием разбора кода программы и осуществляет общий контроль, обнаруживая такие ошибки, как одинаковые объекты, определённые в разных файлах, или объекты, чьи значения не используются в работе программы, переменные с некорректно заданными значениями и типами и многое другое.


